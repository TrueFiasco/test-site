<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesseract Tutorial - Interactive TouchDesigner Guide</title>
  <link rel="stylesheet" href="./layoutTesseract.css" />
</head>
<body>
  <!-- Hero Section -->
  <div class="hero-section" id="heroSection">
    <canvas class="hypercube-canvas" id="hypercube-canvas"></canvas>
    
    <div class="click-hint">Click anywhere to start tutorial</div>
    <button class="nav-btn close-btn" onclick="window.history.back()" style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">√ó</button>
    
    <!-- Settings Toggle -->
    <div class="settings-toggle" id="settings-toggle">
      <svg viewBox="0 0 24 24">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
      </svg>
    </div>

    <!-- üÜï FRAMEWORK-GENERATED CONTROLS PANEL -->
    <!-- Replaces all hardcoded control elements with dynamic generation -->
    <div class="controls-panel" id="controls-panel">
      <!-- Content will be generated by ControlPanelRenderer from TesseractControlConfig -->
    </div>
    
    <div class="hero-content">
      <h1 class="hero-title" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TESSERACT</h1>
      <p class="hero-subtitle" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TouchDesigner Tutorial using GLSL<br>Interactive 4D Hypercube Visualization</p>
    </div>
  </div>
  
  <!-- Mobile-only tutorial button -->
  <div class="mobile-tutorial-button" id="mobileTutorialBtn" style="z-index: 1000;">
    <button class="mobile-start-btn" id="mobileStartBtn">Start Tutorial</button>
  </div>
  
  <!-- Swipe Indicators -->
  <div class="swipe-indicator left" id="swipeIndicatorLeft">‚Üê Previous</div>
  <div class="swipe-indicator right" id="swipeIndicatorRight">Next ‚Üí</div>
  
  <!-- DYNAMIC TUTORIAL CONTAINER -->
  <div class="tutorial-container" id="tutorialContainer">
    <div class="tutorial-header">
      <div class="tutorial-title" id="currentSectionTitle">TESSERACT Overview</div>
      <div class="tutorial-nav">
        <button class="nav-btn" onclick="goToHero()">Home</button>
        <button class="nav-btn" onclick="goToTutorialsPage()">Tutorials</button>
        <button class="nav-btn circular" onclick="goToPrevSection()">‚Äπ</button>
        <button class="nav-btn circular" onclick="goToNextSection()">‚Ä∫</button>
        <button class="nav-btn close-btn" onclick="closeTutorial()">√ó</button>
      </div>
    </div>

    <div class="tutorial-content">
      <div class="tutorial-scroller" id="tutorialScroller">
        <!-- ALL 14 sections will be dynamically generated here -->
      </div>
    </div>

    <!-- Static Image Container -->
    <div class="static-image-container">
      <div class="image-transition-container" id="staticImageContainer">
        <!-- HotspotManager will create and manage hotspots here -->
        <div id="hotspotContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
      </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>
  </div>

  <!-- Copy Notification -->
  <div class="copy-notification" id="copyNotification">Copied to clipboard!</div>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- üÜï FRAMEWORK CORE MODULES (New) -->
  <script src="../../framework/core/genericShader.js"></script>
  <script src="../../framework/core/controlPanelRenderer.js"></script>
  
  <!-- EXISTING FRAMEWORK MODULES -->
  <script src="../../framework/core/contentBlockManager.js"></script>
  <script src="../../framework/core/hotspotManager.js"></script>
  
  <!-- EXISTING SHARED COMPONENTS -->
  <script src="../../shared/components/mobileSwipeGestures.js"></script>
  <script src="../../shared/components/mobileMotionControl.js"></script>

  <!-- üÜï TUTORIAL-SPECIFIC CONFIG (New) -->
  <script src="./controlConfig.js"></script>
  
  <!-- TUTORIAL-SPECIFIC FILES -->
  <script src="./shaders/shaderTesseract.js"></script>
  <script src="./content.js"></script>
  <script src="./hotspots.js"></script>
  
  <script>
  window.validateContentStructure();
  </script>

  <script>
    // ==========================================
    // CONFIGURATION
    // ==========================================
    
    // Section titles
    const sectionTitles = [
      "TESSERACT Tutorial",
      "TESSERACT Overview", 
      "The CHOP Network",
      "Input Data 1: Mouse UV Control",
      "Rangeling CHOPs 1: Mouse Velocity",
      "Rangeling CHOPs 2: Centering and Scaling", 
      "Rangeling CHOPs 3: Angular Velocity",
      "Rangeling CHOPs 4: Mouse Wheel",
      "Rangeling CHOPs 5: Merging and Null",
      "Input Data 2: Saved Data from TSV",
      "Rotation Vertex GLSL",
      "Perspective GLSL", 
      "2D Points to 2D Lines",
      "SDF Uneven Capsule",
      "Post Processing"
    ];

    // Tutorial State
    let currentSection = 0;
    let tutorialOpen = false;
    let cleanupTimeout = null;

    window.currentSection = currentSection;
    window.tutorialOpen = tutorialOpen;

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Initialize instances
    let tesseractShader = null;
    let controlPanelRenderer = null; // üÜï NEW: Control panel renderer
    let mobileSwipeGestures = null;
    let mobileMotionControl = null;
    let contentManager = null;
    let hotspotManager = null;

    // ==========================================
    // ENHANCED HOTSPOT SYSTEM INTEGRATION
    // ==========================================

    // Initialize HotspotManager
    async function initHotspotManager() {
      try {
        console.log('üéØ Initializing HotspotManager...');
        
        hotspotManager = await HotspotManager.create({
          basePath: '',
          containerSelector: '#hotspotContainer',
          enableCollisionAvoidance: true,
          enableMultiDialog: true,
          maxDialogs: 5,
          dialogOffset: { x: 10, y: 0 }
        });
        
        console.log('‚úÖ HotspotManager initialized successfully');
        
        if (currentSection > 0) {
          hotspotManager.updateHotspots(currentSection);
        }
        
        return hotspotManager;
      } catch (error) {
        console.error('‚ùå Failed to initialize HotspotManager:', error);
        return null;
      }
    }

    // Legacy function kept for compatibility
    function updateHotspots(hotspots) {
      if (hotspotManager) {
        hotspotManager.updateHotspots(currentSection);
      } else {
        console.warn('‚ö†Ô∏è HotspotManager not initialized, skipping hotspot update');
      }
    }

    // Legacy function for ESC key
    function hideParameterDialog() {
      if (hotspotManager) {
        hotspotManager.hideAllDialogs();
      }
    }

    // ==========================================
    // DYNAMIC CONTENT SYSTEM
    // ==========================================

    // Generate all tutorial sections from the content file
    function generateTutorialSections() {
      console.log('üìÑ Generating tutorial sections from content.js...');
      
      if (!window.TesseractContent) {
        throw new Error('TesseractContent not loaded');
      }

      const tutorialScroller = document.getElementById('tutorialScroller');
      if (!tutorialScroller) {
        throw new Error('Tutorial scroller element not found');
      }

      tutorialScroller.innerHTML = '';

      TesseractContent.tutorial.sections.forEach((sectionConfig, index) => {
        const sectionElement = document.createElement('div');
        sectionElement.className = 'tutorial-section';
        sectionElement.dataset.sectionId = sectionConfig.id;
        
        if (sectionConfig.id > 0 && sectionConfig.id <= 14) {
          sectionElement.classList.add('has-background-image');
        }
        
        sectionElement.innerHTML = `
          <div style="padding: 2rem; text-align: center; color: #888;">
            <p>Loading section ${sectionConfig.id}...</p>
          </div>
        `;
        
        tutorialScroller.appendChild(sectionElement);
      });
      
      console.log(`‚úÖ Generated ${TesseractContent.tutorial.sections.length} tutorial sections`);
    }

    // Render a specific section using ContentBlockManager
    async function renderSection(sectionId) {
      const sectionElement = document.querySelector(`[data-section-id="${sectionId}"]`);
      if (!sectionElement) {
        console.warn(`Section ${sectionId} element not found`);
        return;
      }

      const sectionConfig = TesseractContent.tutorial.sections.find(s => s.id === sectionId);
      if (!sectionConfig) {
        console.warn(`Section ${sectionId} configuration not found`);
        return;
      }

      console.log(`üé® Rendering section ${sectionId}: ${sectionConfig.title}`);
      
      try {
        await contentManager.renderSection(sectionConfig, sectionElement);
        console.log(`‚úÖ Section ${sectionId} rendered successfully`);
      } catch (error) {
        console.error(`‚ùå Failed to render section ${sectionId}:`, error);
        sectionElement.innerHTML = `
          <div style="color: #ff6b6b; padding: 2rem; text-align: center;">
            <h3>Content Loading Error</h3>
            <p>Failed to load section content: ${error.message}</p>
            <p style="font-size: 0.8rem; margin-top: 1rem;">Please check the console for details.</p>
          </div>
        `;
      }
    }

    // Initialize ContentBlockManager
    function initContentManager() {
      contentManager = new ContentBlockManager({
        basePath: '',
        enableMarkdown: true,
        enableWidgets: true,
        enableSyntaxHighlighting: true
      });
      
      console.log('‚úÖ ContentBlockManager initialized');
    }

    // ==========================================
    // üÜï NEW FRAMEWORK CONTROL PANEL SETUP
    // ==========================================

    /**
     * Initialize the new framework-based control panel with automatic settings button management
     */
    async function initFrameworkControlPanel() {
      // Wait for shader to be initialized
      if (!tesseractShader || !tesseractShader.isInitialized) {
        console.log('‚è≥ Waiting for shader to initialize before setting up controls...');
        setTimeout(initFrameworkControlPanel, 100);
        return;
      }

      // Check if TesseractControlConfig is available
      if (!window.TesseractControlConfig) {
        console.error('‚ùå TesseractControlConfig not loaded');
        return;
      }

      try {
        console.log('üé® Initializing framework control panel with automatic settings button management...');
        
        // Create control panel renderer with Tesseract config
        controlPanelRenderer = new ControlPanelRenderer(
          tesseractShader, 
          window.TesseractControlConfig,
          { 
            containerId: 'controls-panel',
            settingsButtonId: 'settings-toggle'
          }
        );
        
        // üÜï NEW: Use framework method that handles everything automatically
        controlPanelRenderer.renderWithSettingsButton();
        
        console.log('‚úÖ Framework control panel with automatic settings button management initialized');
        
        // Setup additional integrations
        setupMotionControlIntegration();
        
      } catch (error) {
        console.error('‚ùå Failed to initialize framework control panel:', error);
        // Fallback to minimal controls
        createFallbackControls();
      }
    }

    /**
     * Setup motion control integration with framework consent system
     */
    function setupMotionControlIntegration() {
      // Integrate mobile motion control with framework consent
      if (isMobile && mobileMotionControl) {
        // Check if user has previously consented
        const previousConsent = GenericShader.getMotionConsent();
        
        if (previousConsent === true) {
          // Auto-enable motion control if previously consented
          tesseractShader.enableMotionControl();
          console.log('üì± Auto-enabled motion control from previous consent');
        } else if (previousConsent === false) {
          // User previously declined, respect that choice
          console.log('üì± Motion control disabled due to previous user choice');
        } else {
          // First time - will be handled by motion control button in panel
          console.log('üì± Motion control available - user can enable via control panel');
        }
      }
    }

    /**
     * Create fallback controls if framework fails
     */
    function createFallbackControls() {
      const controlsPanel = document.getElementById('controls-panel');
      if (controlsPanel) {
        controlsPanel.innerHTML = `
          <h4>4D Projection Controls</h4>
          <div class="control-group">
            <label>FOV:</label>
            <input type="number" id="fallback-fov" value="7" min="2" max="120">
          </div>
          <div class="button-group">
            <button class="control-button wide" id="fallback-reset">Reset Rotation</button>
          </div>
          <div class="info-section">
            <p>Minimal fallback controls - Framework integration failed</p>
          </div>
        `;
        
        // Basic event binding
        document.getElementById('fallback-fov')?.addEventListener('input', (e) => {
          tesseractShader.setParameter('fov', parseFloat(e.target.value));
        });
        
        document.getElementById('fallback-reset')?.addEventListener('click', () => {
          tesseractShader.resetRotation();
        });
        
        console.log('‚ö†Ô∏è Fallback controls created');
      }
    }

    // ==========================================
    // NAVIGATION FUNCTIONS
    // ==========================================

    function openTutorial() {
      console.log('üöÄ openTutorial called - starting tutorial!');
      
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      if (mobileBtn) {
        mobileBtn.style.opacity = '0';
        mobileBtn.style.visibility = 'hidden';
        mobileBtn.style.pointerEvents = 'none';
      }
      
      transitionToSection(1);
      initProgressBar();
    }

    function closeTutorial() {
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      
      if (hotspotManager) {
        hotspotManager.clearHotspots();
      }
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      if (mobileBtn && isMobile) {
        mobileBtn.style.opacity = '1';
        mobileBtn.style.visibility = 'visible';
        mobileBtn.style.pointerEvents = 'auto';
      }
      
      transitionToSection(0);
    }

    function goToNextSection() {
      if (currentSection < 14) {
        transitionToSection(currentSection + 1);
      }
    }

    function goToPrevSection() {
      if (currentSection > 1) {
        transitionToSection(currentSection - 1);
      }
    }

    async function transitionToSection(newSection) {
      if (newSection === currentSection) return;
      
      currentSection = newSection;
      window.currentSection = currentSection;
      
      console.log(`üîÑ Transitioning to section ${newSection}`);
      
      updateSectionTitle();
      updateTutorial();
      
      if (currentSection > 0 && currentSection <= 14) {
        await renderSection(currentSection);
        transitionStaticImage(currentSection);
      }
    }

    function updateTutorial() {
      const scroller = document.getElementById('tutorialScroller');
      const tutorialContainer = document.getElementById('tutorialContainer');
      const progressBar = document.getElementById('progressBar');
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      const settingsToggle = document.getElementById('settings-toggle');
      
      if (currentSection === 0) {
        console.log('üè† Switching to hero section - showing settings');
        
        if (tutorialContainer) {
          tutorialContainer.classList.remove('active');
        }
        if (progressBar) {
          progressBar.style.display = 'none';
        }
        
        if (settingsToggle) {
          settingsToggle.style.display = 'flex';
          settingsToggle.style.opacity = '1';
          settingsToggle.style.visibility = 'visible';
          settingsToggle.style.pointerEvents = 'auto';
          console.log('‚úÖ Settings button made visible');
        }
        
        if (mobileBtn && isMobile) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.pointerEvents = 'auto';
        }
        
        if (mobileMotionControl && isMobile) {
          mobileMotionControl.enable();
        }
        
        if (hotspotManager) {
          hotspotManager.clearHotspots();
        }
        
        tutorialOpen = false;
        window.tutorialOpen = false;
        
      } else {
        console.log(`üìö Switching to tutorial section ${currentSection} - hiding settings`);
        
        if (tutorialContainer) {
          tutorialContainer.classList.add('active');
        }
        if (progressBar) {
          progressBar.style.display = 'flex';
        }
        
        if (settingsToggle) {
          settingsToggle.style.display = 'none';
          settingsToggle.style.opacity = '0';
          settingsToggle.style.visibility = 'hidden';
          settingsToggle.style.pointerEvents = 'none';
          console.log('‚úÖ Settings button hidden');
        }
        
        if (mobileBtn) {
          mobileBtn.style.opacity = '0';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.pointerEvents = 'none';
        }
        
        if (mobileMotionControl && isMobile) {
          mobileMotionControl.disable();
        }
        
        tutorialOpen = true;
        window.tutorialOpen = true;
        
        if (scroller) {
          const offset = (currentSection - 1) * -100;
          scroller.style.transform = `translateX(${offset}vw)`;
        }
      }
      
      updateProgressBar();
    }

    function updateSectionTitle() {
      const titleElement = document.getElementById('currentSectionTitle');
      if (titleElement && currentSection >= 0 && currentSection < sectionTitles.length) {
        titleElement.textContent = sectionTitles[currentSection];
      }
    }

    function initProgressBar() {
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.innerHTML = '';
        
        for (let i = 1; i <= 14; i++) {
          const dot = document.createElement('div');
          dot.className = 'progress-dot';
          if (i === currentSection) dot.classList.add('active');
          dot.onclick = () => transitionToSection(i);
          progressBar.appendChild(dot);
        }
      }
    }

    function updateProgressBar() {
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', (index + 1) === currentSection);
      });
    }

    function setupMobileButton() {
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      const startBtn = document.getElementById('mobileStartBtn');
      
      if (isMobile) {
        if (mobileBtn && startBtn) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.pointerEvents = 'auto';
          
          startBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            openTutorial();
          });
        }
      } else {
        if (mobileBtn) {
          mobileBtn.style.display = 'none';
        }
      }
    }

    // ==========================================
    // IMAGE TRANSITIONS & HOTSPOTS
    // ==========================================

    let currentTransition = null;
    let transitionCounter = 0;

    function transitionStaticImage(newSection) {
      const sectionData = TesseractContent.tutorial.sections.find(s => s.id === newSection);
      if (!sectionData || !sectionData.background) return;

      const config = {
        aspectRatio: sectionData.background.aspectRatio,
        offset: sectionData.background.transition?.offset || { x: 0, y: 0 },
        image: sectionData.background.image,
      };

      const imageContainer = document.getElementById('staticImageContainer');
      if (!imageContainer) return;
    
      if (currentTransition) {
        currentTransition.cancelled = true;
      }
      
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }

      const transitionId = ++transitionCounter;
      currentTransition = { id: transitionId, cancelled: false };
      
      const existingImages = imageContainer.querySelectorAll('.tutorial-image');
      const currentImage = existingImages.length > 0 ? existingImages[existingImages.length - 1] : null;
      
      const newImage = document.createElement('img');
      newImage.className = 'tutorial-image';
      newImage.style.aspectRatio = config.aspectRatio.replace(':', '/');
      newImage.src = config.image;
      newImage.dataset.transitionId = transitionId;

      if (config.offset.x === 0 && config.offset.y === 0) {
        newImage.style.transform = 'translate(0, 0)';
        newImage.style.opacity = '0';
        newImage.style.zIndex = '10';
      } else {
        const startX = config.offset.x * 100;
        const startY = config.offset.y * 100;
        newImage.style.transform = `translate(${startX}%, ${startY}%)`;
        newImage.style.opacity = '0';
        newImage.style.zIndex = '10';
      }

      if (currentImage) {
        currentImage.style.zIndex = '5';
      }

      imageContainer.appendChild(newImage);
      
      function executeTransition() {
        if (currentTransition.cancelled || currentTransition.id !== transitionId) {
          newImage.remove();
          return;
        }
        
        if (hotspotManager) {
          hotspotManager.updateHotspots(newSection);
        }

        setTimeout(() => {
          if (currentTransition.cancelled || currentTransition.id !== transitionId) {
            newImage.remove();
            return;
          }

          newImage.style.opacity = '1';
          newImage.style.transform = 'translate(0, 0)';

          if (currentImage && currentImage.parentNode === imageContainer) {
            if (config.offset.x === 0 && config.offset.y === 0) {
              currentImage.style.opacity = '0';
            } else {
              const exitX = -config.offset.x * 100;
              const exitY = -config.offset.y * 100;
              currentImage.style.transform = `translate(${exitX}%, ${exitY}%)`;
              currentImage.style.opacity = '0';
            }
          }

          cleanupTimeout = setTimeout(() => {
            if (currentTransition.id === transitionId) {
              const allImages = imageContainer.querySelectorAll('.tutorial-image');
              allImages.forEach(img => {
                if (img !== newImage && img.parentNode === imageContainer) {
                  imageContainer.removeChild(img);
                }
              });
              
              if (currentTransition.id === transitionId) {
                currentTransition = null;
              }
            }
            cleanupTimeout = null;
          }, 850);
        }, 10);
      }
      
      if (newImage.complete) {
        executeTransition();
      } else {
        newImage.onload = executeTransition;
        newImage.onerror = () => {
          console.error('Failed to load image:', config.image);
          if (currentTransition.id === transitionId) {
            newImage.remove();
            currentTransition = null;
          }
        };
      }
    }

    function onWheel(event) {
      const anyModalOpen = document.querySelector('.widget-fullscreen.active');
      
      if (anyModalOpen) {
        return;
      }
    
      if (tutorialOpen) {
        event.preventDefault();
        const delta = event.deltaY;
        
        if (delta > 0) {
          goToNextSection();
        } else {
          goToPrevSection();
        }
        return;
      }
    }

    // Make functions globally accessible
    window.openTutorial = openTutorial;
    window.closeTutorial = closeTutorial;
    window.goToNextSection = goToNextSection;
    window.goToPrevSection = goToPrevSection;
    window.transitionToSection = transitionToSection;
    window.goToHero = () => transitionToSection(0);
    window.goToTutorialsPage = () => window.history.back();
    window.hideParameterDialog = hideParameterDialog;

    // ==========================================
    // SIMPLE SETTINGS BUTTON HANDLER
    // ==========================================
    function setupSettingsButton() {
      const settingsToggle = document.getElementById('settings-toggle');
      const controlsPanel = document.getElementById('controls-panel');
      
      if (!settingsToggle || !controlsPanel) {
        console.error('‚ùå Settings button or controls panel not found');
        return;
      }
      
      // Remove existing listeners to prevent conflicts
      const newButton = settingsToggle.cloneNode(true);
      settingsToggle.parentNode.replaceChild(newButton, settingsToggle);
      
      // Simple toggle function
      let panelOpen = false;
      
      // SINGLE CLEAN EVENT HANDLER
      newButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        console.log('‚öôÔ∏è Settings button clicked, panel open:', panelOpen);
        
        if (panelOpen) {
          closePanel();
        } else {
          openPanel();
        }
      });
      
      // PREVENT EVENT CONFLICTS ON PANEL
      controlsPanel.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent clicks on panel from bubbling
      });
      
      function openPanel() {
        console.log('‚úÖ Opening panel');
        
        controlsPanel.style.display = 'block';
        controlsPanel.style.opacity = '1';
        controlsPanel.style.visibility = 'visible';
        controlsPanel.style.pointerEvents = 'auto';
        
        // Ensure button stays on top
        newButton.style.zIndex = '99999';
        newButton.style.pointerEvents = 'auto';
        
        panelOpen = true;
        
        // Add backdrop for easy closing
        addBackdrop();
      }
      
      function closePanel() {
        console.log('‚úÖ Closing panel');
        
        controlsPanel.style.display = 'none';
        controlsPanel.style.opacity = '0';
        controlsPanel.style.visibility = 'hidden';
        controlsPanel.style.pointerEvents = 'none';
        
        panelOpen = false;
        
        removeBackdrop();
      }
      
      function addBackdrop() {
        removeBackdrop(); // Remove existing first
        
        const backdrop = document.createElement('div');
        backdrop.id = 'simple-backdrop';
        backdrop.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: rgba(0, 0, 0, 0.3);
          z-index: 1999;
          pointer-events: auto;
        `;
        
        backdrop.addEventListener('click', function(e) {
          e.preventDefault();
          closePanel();
        });
        
        document.body.appendChild(backdrop);
      }
      
      function removeBackdrop() {
        const backdrop = document.getElementById('simple-backdrop');
        if (backdrop) {
          backdrop.remove();
        }
      }
      
      // Close on escape
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panelOpen) {
          closePanel();
        }
      });
      
      console.log('‚úÖ Simple settings button setup complete');
    }
    
    // ==========================================
    // üÜï ENHANCED INITIALIZATION WITH FRAMEWORK
    // ==========================================

    async function init() {
      try {
        console.log('üöÄ Starting enhanced tutorial initialization with framework integration...');
        
        // 1. Initialize content management
        initContentManager();
        generateTutorialSections();
        console.log('‚úÖ Tutorial sections generated');
        
        // 2. Initialize hotspot management
        await initHotspotManager();
        
        // 3. Initialize Tesseract shader (now extends GenericShader)
        tesseractShader = new TesseractShader('hypercube-canvas', {
          onTutorialOpen: openTutorial,
          getTutorialState: () => tutorialOpen
        });
        
        await tesseractShader.init();
        console.log('‚úÖ TesseractShader (framework integration) initialized');
        
        // 4. üÜï Initialize framework control panel
        await initFrameworkControlPanel();
        
        // 5. Initialize mobile components
        if (isMobile) {
          try {
            mobileSwipeGestures = new MobileSwipeGestures();
            console.log('‚úÖ Mobile swipe gestures initialized');
          } catch (error) {
            console.warn('‚ö†Ô∏è Mobile swipe gestures failed to initialize:', error);
          }
          
          try {
            mobileMotionControl = new MobileMotionControl(tesseractShader);
            window.mobileMotionControl = mobileMotionControl;
            console.log('‚úÖ Mobile motion control initialized');
          } catch (error) {
            console.warn('‚ö†Ô∏è Mobile motion control failed to initialize:', error);
          }
        }
        
        // 6. Setup UI components
        initProgressBar();
        updateSectionTitle();
        setupMobileButton();
        // üÜï REMOVED: setupSettingsButton() - now handled automatically by framework
        
        // 7. Setup event listeners
        document.addEventListener('wheel', onWheel, { passive: false });
        
        console.log('üéâ Enhanced tutorial with framework integration complete!');
        console.log('üéØ Framework Features Enabled:');
        console.log('  ‚Ä¢ GenericShader base class with parameter management');
        console.log('  ‚Ä¢ ControlPanelRenderer with automatic settings button management'); 
        console.log('  ‚Ä¢ Integrated motion consent persistence across pages');
        console.log('  ‚Ä¢ Configuration-driven control system');
        console.log('  ‚Ä¢ Reusable framework components');
        console.log('  ‚Ä¢ Zero hardcoded event handling - all framework managed');
        console.log('üìù Next tutorial will only need: config.js + shader.js files');
        
      } catch (error) {
        console.error('‚ùå Failed to initialize enhanced tutorial with framework:', error);
        createFallbackUI(error);
      }
    }

    function createFallbackUI(error) {
      const heroSection = document.getElementById('heroSection');
      if (heroSection) {
        heroSection.innerHTML += `
          <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                      background: rgba(255, 0, 0, 0.8); color: white; padding: 2rem; border-radius: 10px;
                      text-align: center; z-index: 9999;">
            <h2>Framework Integration Error</h2>
            <p>Failed to initialize tutorial with framework: ${error.message}</p>
            <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; 
                    background: white; color: black; border: none; border-radius: 5px; cursor: pointer;">
              Reload Page
            </button>
          </div>
        `;
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    // Event listeners
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.widget-fullscreen.active').forEach(modal => {
          modal.classList.remove('active');
        });
        
        if (hotspotManager) {
          hotspotManager.hideAllDialogs();
        }
      }
    });

    window.addEventListener('beforeunload', () => {
      if (mobileSwipeGestures) {
        mobileSwipeGestures.destroy();
      }
      if (mobileMotionControl) {
        mobileMotionControl.destroy();
      }
      if (tesseractShader) {
        tesseractShader.destroy();
      }
      if (contentManager) {
        contentManager.destroy();
      }
      if (hotspotManager) {
        hotspotManager.destroy();
      }
      if (controlPanelRenderer) {
        controlPanelRenderer.destroy();
      }
    });
    
    /**
 * NUCLEAR MOBILE POSITIONING FIX - JavaScript Enforcement
 * Add this code to the END of your index.html <script> section
 * This will continuously enforce correct positioning
 */

// NUCLEAR MOBILE POSITIONING ENFORCER
function nuclearMobilePositionFix() {
  const isMobile = window.innerWidth <= 768;
  const settingsButton = document.getElementById('settings-toggle');
  const controlsPanel = document.getElementById('controls-panel');
  
  if (!settingsButton) return;
  
  console.log('üöÄ NUCLEAR positioning fix running...', { isMobile, buttonExists: !!settingsButton });
  
  if (isMobile) {
    // MOBILE: Force top-left positioning
    settingsButton.style.cssText = `
      position: fixed !important;
      top: 1rem !important;
      left: 1rem !important;
      right: auto !important;
      bottom: auto !important;
      z-index: 999999 !important;
      width: 56px !important;
      height: 56px !important;
      min-width: 56px !important;
      min-height: 56px !important;
      max-width: 56px !important;
      max-height: 56px !important;
      transform: none !important;
      translate: none !important;
      margin: 0 !important;
      padding: 0 !important;
      display: flex !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      background: rgba(0, 0, 0, 0.9) !important;
      backdrop-filter: blur(10px) !important;
      border-radius: 50% !important;
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      align-items: center !important;
      justify-content: center !important;
    `;
    
    if (controlsPanel) {
      controlsPanel.style.cssText = `
        position: fixed !important;
        top: 80px !important;
        left: 1rem !important;
        right: 1rem !important;
        bottom: auto !important;
        z-index: 2000 !important;
        width: auto !important;
        min-width: auto !important;
        max-width: none !important;
        max-height: calc(100vh - 120px) !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        transform: none !important;
        translate: none !important;
        margin: 0 !important;
        background: rgba(0, 0, 0, 0.8) !important;
        padding: 1.5rem !important;
        border-radius: 15px !important;
        backdrop-filter: blur(15px) !important;
        border: 1px solid rgba(255, 255, 255, 0.3) !important;
        font-size: 0.9rem !important;
        min-width: 300px !important;
      `;
    }
    
    console.log('‚úÖ MOBILE positioning enforced');
    
  } else {
    // DESKTOP: Force top-left positioning
    settingsButton.style.cssText = `
      position: fixed !important;
      top: 2rem !important;
      left: 2rem !important;
      right: auto !important;
      bottom: auto !important;
      z-index: 99999 !important;
      width: 50px !important;
      height: 50px !important;
      transform: none !important;
      translate: none !important;
      margin: 0 !important;
      padding: 0 !important;
      display: flex !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      background: rgba(0, 0, 0, 0.6) !important;
      backdrop-filter: blur(10px) !important;
      border-radius: 50% !important;
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      align-items: center !important;
      justify-content: center !important;
    `;
    
    if (controlsPanel) {
      controlsPanel.style.cssText = `
        position: fixed !important;
        top: 2rem !important;
        left: 2rem !important;
        right: auto !important;
        bottom: auto !important;
        z-index: 2000 !important;
        width: auto !important;
        min-width: 280px !important;
        max-width: none !important;
        transform: none !important;
        translate: none !important;
        margin: 0 !important;
        background: rgba(0, 0, 0, 0.8) !important;
        padding: 1.5rem !important;
        border-radius: 15px !important;
        backdrop-filter: blur(15px) !important;
        border: 1px solid rgba(255, 255, 255, 0.3) !important;
        font-size: 0.9rem !important;
      `;
    }
    
    console.log('‚úÖ DESKTOP positioning enforced');
  }
}

/**
 * SMART POSITIONING FIX - Only runs when actually needed
 * Replace the previous "NUCLEAR" JavaScript code with this smarter version
 * This won't interfere with dialog state management
 */

// SMART MOBILE POSITIONING ENFORCER - Only when needed
function smartMobilePositionFix() {
  const isMobile = window.innerWidth <= 768;
  const settingsButton = document.getElementById('settings-toggle');
  
  if (!settingsButton) return;
  
  // Only fix if button is in wrong position
  const currentTop = settingsButton.style.top;
  const currentLeft = settingsButton.style.left;
  const currentRight = settingsButton.style.right;
  
  const needsFix = isMobile ? 
    (currentTop !== '1rem' || currentLeft !== '1rem' || currentRight !== 'auto') :
    (currentTop !== '2rem' || currentLeft !== '2rem' || currentRight !== 'auto');
  
  if (!needsFix) return; // Already in correct position
  
  console.log('üîß SMART positioning fix needed:', { isMobile, currentTop, currentLeft });
  
  if (isMobile) {
    // MOBILE: Force top-left positioning ONLY if wrong
    settingsButton.style.position = 'fixed';
    settingsButton.style.top = '1rem';
    settingsButton.style.left = '1rem';
    settingsButton.style.right = 'auto';
    settingsButton.style.zIndex = '999999';
    settingsButton.style.width = '56px';
    settingsButton.style.height = '56px';
    settingsButton.style.transform = 'none';
    
    console.log('‚úÖ MOBILE positioning fixed');
  } else {
    // DESKTOP: Force top-left positioning ONLY if wrong
    settingsButton.style.position = 'fixed';
    settingsButton.style.top = '2rem';
    settingsButton.style.left = '2rem';
    settingsButton.style.right = 'auto';
    settingsButton.style.zIndex = '99999';
    settingsButton.style.width = '50px';
    settingsButton.style.height = '50px';
    settingsButton.style.transform = 'none';
    
    console.log('‚úÖ DESKTOP positioning fixed');
  }
}

// SMART POSITIONING SETUP - Minimal interference
function setupSmartPositioning() {
  console.log('üß† Setting up SMART positioning (no continuous interference)...');
  
  // Run once immediately
  smartMobilePositionFix();
  
  // Run after page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', smartMobilePositionFix);
  }
  
  // Run on window resize (debounced)
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(smartMobilePositionFix, 100);
  });
  
  // Run on orientation change (mobile only)
  if ('orientation' in window) {
    window.addEventListener('orientationchange', () => {
      setTimeout(smartMobilePositionFix, 200);
    });
  }
  
  // NO CONTINUOUS INTERVALS - this was causing the dialog to close
  
  console.log('‚úÖ SMART positioning setup complete - no interference with dialog state');
}

// AUTO-START THE SMART SYSTEM
setupSmartPositioning();

/**
 * CHANGES FROM PREVIOUS VERSION:
 * 
 * ‚úÖ REMOVED: setInterval that ran every 2 seconds (was closing dialog)
 * ‚úÖ REMOVED: Continuous enforcement that interfered with state
 * ‚úÖ ADDED: Smart detection - only fixes if actually wrong
 * ‚úÖ ADDED: Debounced resize handling
 * ‚úÖ KEPT: Initial positioning and orientation change handling
 * 
 * This version will:
 * - Fix positioning once on load
 * - Fix positioning on window resize (debounced)
 * - Fix positioning on orientation change (mobile)
 * - NOT interfere with dialog open/close state
 * - NOT run continuously in the background
 */ 
  </script>
  <!-- TEMPORARY DEBUG BUTTON - Add this to your index.html -->
<button id="motion-debug-btn" style="position: fixed; top: 60px; right: 10px; z-index: 99999; 
       background: red; color: white; padding: 10px; border: none; border-radius: 5px;">
  Start Motion Debug
</button>

<div id="motion-debug-display" style="position: fixed; top: 120px; left: 10px; right: 10px; 
     background: rgba(0,0,0,0.9); color: white; padding: 10px; font-family: monospace; 
     font-size: 12px; z-index: 99999; border-radius: 8px; display: none;">
  Debug info will appear here...
</div>

  <script>
  // PERMISSION FIX Debug System
  document.getElementById('motion-debug-btn').addEventListener('click', function() {
    let eventCount = 0;
    const debugDiv = document.getElementById('motion-debug-display');
    debugDiv.style.display = 'block';
    this.textContent = 'Debug Active';
    this.style.background = 'green';
    
    const motionControl = window.mobileMotionControl;
    const shader = window.tesseractShader;
    
    // CHECK ALL PERMISSION KEYS
    debugDiv.innerHTML = `
      <strong>PERMISSION DEBUG:</strong><br>
      motionControlConsent: ${localStorage.getItem('motionControlConsent')}<br>
      tutorial_motion_consent: ${localStorage.getItem('tutorial_motion_consent')}<br>
      <br>
      <strong>FIXING PERMISSIONS...</strong><br>
    `;
    
    // FIX: Set both permission keys
    localStorage.setItem('motionControlConsent', 'granted');
    localStorage.setItem('tutorial_motion_consent', 'true');
    
    // FIX: Manually override permission
    if (motionControl) {
      motionControl.isPermissionGranted = true;
      motionControl.isActive = true;
      
      // Set global variables
      window.currentSection = 0;
      window.tutorialOpen = false;
      
      // Force calibration
      motionControl.calibrateOrientation();
      
      // Enable shader
      if (shader) {
        shader.enableDeviceOrientation();
      }
    }
    
    setTimeout(() => {
      debugDiv.innerHTML += `
        <br><strong>AFTER FIX:</strong><br>
        Motion Permission: ${motionControl ? motionControl.isPermissionGranted : 'N/A'}<br>
        Motion Active: ${motionControl ? motionControl.isActive : 'N/A'}<br>
        Shader Motion: ${shader ? shader.deviceOrientationEnabled : 'N/A'}<br>
        Current Section: ${window.currentSection}<br>
        Tutorial Open: ${window.tutorialOpen}<br>
      `;
      
      // Start monitoring events
      window.addEventListener('deviceorientation', (event) => {
        eventCount++;
        if (eventCount % 10 === 0) { // Update every 10 events to avoid spam
          debugDiv.innerHTML += `<br>Events: ${eventCount}, CameraRX: ${shader?.angles?.cameraRx?.toFixed(3) || 'N/A'}`;
        }
      });
      
    }, 1000);
  });
  </script>
</body>
</html>
