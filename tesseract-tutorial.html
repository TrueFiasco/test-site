<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesseract Tutorial - Interactive TouchDesigner Guide</title>
  <link rel="stylesheet" href="layoutTesseract.css" />
</head>
<body>
  <!-- Hero Section -->
  <div class="hero-section" id="heroSection">
    <canvas class="hypercube-canvas" id="hypercube-canvas"></canvas>
    
    <!-- Desktop Click Hint -->
    <div class="click-hint">Click anywhere to start tutorial</div>
    
    <!-- Back Button -->
    <button class="nav-btn close-btn" onclick="window.history.back()" style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">√ó</button>
    
    <!-- Settings Toggle -->
    <div class="settings-toggle" id="settings-toggle">
      <svg viewBox="0 0 24 24">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
      </svg>
    </div>

    <!-- Enhanced Controls Panel -->
    <div class="controls-panel" id="controls-panel">
      <h4>4D Projection Controls</h4>
      
      <!-- Parameter Controls -->
      <div class="control-group">
        <label for="fov-control">FOV:</label>
        <input type="number" id="fov-control" value="7" step="1" min="2" max="120">
      </div>
      <div class="control-group">
        <label for="perspective-control">4D Scale:</label>
        <input type="number" id="perspective-control" value="2.3" step="0.1" min="0.1" max="10">
      </div>
      <div class="control-group">
        <label for="cameraz-control">Camera Z:</label>
        <input type="number" id="cameraz-control" value="10" step="1" min="-100" max="50">
      </div>
      
      <!-- Filter Strength Control -->
      <div class="control-group">
        <label for="filter-strength">Filter:</label>
        <input type="range" id="filter-strength" value="0.1" min="0.01" max="1" step="0.01" style="width: 80px;" title="Parameter change smoothing">
      </div>
      
      <!-- Motion Control Override (mobile only) -->
      <div class="control-group mobile-only" id="motion-control-group">
        <label for="motion-control-toggle">Motion Control:</label>
        <button class="control-button" id="motion-control-toggle" style="width: 80px; padding: 0.2rem 0.5rem; font-size: 0.75rem;">Enable</button>
      </div>
      
      <div class="button-group">
        <!-- Reset Button -->
        <button class="control-button wide" id="reset-rotation">Reset Rotation</button>
        
        <!-- Desktop Rotation Controls -->
        <div class="desktop-only">
          <div class="button-row">
            <button class="control-button" id="stop-rx">Stop RX</button>
            <button class="control-button" id="stop-ry">Stop RY</button>
            <button class="control-button" id="stop-rw">Stop RW</button>
          </div>
        </div>
        
        <!-- Mobile Enhanced Controls -->
        <div class="mobile-only">
          <div class="button-row">
            <button class="control-button" id="stop-rx-mobile">Stop RX</button>
            <button class="control-button" id="stop-ry-mobile">Stop RY</button>
            <button class="control-button" id="stop-rw-mobile">Stop RW</button>
          </div>
          <div class="button-row">
            <button class="control-button" id="stop-motion">Stop Motion</button>
            <button class="control-button" id="stop-touch">Stop Touch</button>
            <button class="control-button" id="invert-x">Fix X-Axis</button>
          </div>
        </div>
      </div>
      
      <div class="info-section">
        <h4>4D Hypercube Controls</h4>
        <p class="desktop-only">‚Ä¢ Click anywhere to start tutorial</p>
        <p class="desktop-only">‚Ä¢ Move mouse to rotate in 3D space</p>
        <p class="desktop-only">‚Ä¢ Scroll to rotate through 4th dimension</p>
        <p class="mobile-only">‚Ä¢ Tap button below to start tutorial</p>
        <p class="mobile-only">‚Ä¢ Tilt device to rotate hypercube</p>
        <p class="mobile-only">‚Ä¢ Touch and drag for manual control</p>
        <p class="mobile-only">‚Ä¢ Use "Motion Control" above to enable device tilt</p>
      </div>
    </div>
    
    <div class="hero-content">
      <!-- Hidden HTML titles - only shader text will be visible -->
      <h1 class="hero-title" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TESSERACT</h1>
      <p class="hero-subtitle" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TouchDesigner Tutorial using GLSL<br>Interactive 4D Hypercube Visualization</p>
    </div>
  </div>
  
  <!-- Mobile-only tutorial button -->
  <div class="mobile-tutorial-button" id="mobileTutorialBtn" style="z-index: 1000;">
    <button class="mobile-start-btn" id="mobileStartBtn">
      Start Tutorial
    </button>
  </div>
  
  <!-- Swipe Indicators -->
  <div class="swipe-indicator left" id="swipeIndicatorLeft">‚Üê Previous</div>
  <div class="swipe-indicator right" id="swipeIndicatorRight">Next ‚Üí</div>
  
  <!-- Motion Control UI -->
  <div class="motion-indicator" id="motionIndicator" title="Motion Control">üì±</div>
  
  <div class="motion-permission-prompt" id="motionPermissionPrompt">
    <h4>Enhanced Experience</h4>
    <p>Enable motion control to rotate the hypercube by tilting your device</p>
    <div class="motion-permission-buttons">
      <button class="motion-btn" id="enableMotionBtn">Enable</button>
      <button class="motion-btn decline" id="declineMotionBtn">No thanks</button>
    </div>
  </div>
  
  <!-- Tutorial Container Placeholder - will be loaded dynamically -->
  <div id="tutorialContainer"></div>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Core Shader Module -->
  <script src="tutorials/tesseract/shaders/shaderTesseract.js"></script>
  
  <!-- Enhanced Feature Modules -->
  <script src="shared/components/enhancedControlPanel.js"></script>
  <script src="shared/components/mobileSwipeGestures.js"></script>
  <script src="shared/components/mobileMotionControl.js"></script>

  <script>
    // ==========================================
    // TUTORIAL CONFIGURATION & STATE
    // ==========================================
    // Create proper mapping for parameter images
    const parameterImageMap = {
      'select1-detailed': 'select1.png',
      'math3-params': 'math3.png',
      'filter1-params': 'filter1.png',
      'math1-params': 'math1.png',
      'speed2-params': 'speed2.png',
      'math2-params': 'math2.png',
      'speed3-params': 'speed3.png',
      'mousein1-wheel': 'mousein1.png',
      'select2-params': 'select2.png',
      'filter4-params': 'filter4.png',
      'filter3-params': 'filter3.png',
      'filter2-params': 'filter2.png',
      'vert_rotation': 'vert_rotation.png',
      'vert_perspective': 'vert_perspective.png',
      'transform1': 'transform1.png',
      'reorder1': 'reorder1.png',
      'line_mindist': 'line_mindist.png'
    };
    
    // Create proper titles for parameters
    const parameterTitleMap = {
      'select1-detailed': 'Select1 CHOP Parameters',
      'math3-params': 'Math3 CHOP Parameters',
      'filter1-params': 'Filter1 CHOP Parameters',
      'math1-params': 'Math1 CHOP Parameters',
      'speed2-params': 'Speed2 CHOP Parameters',
      'math2-params': 'Math2 CHOP Parameters',
      'speed3-params': 'Speed3 CHOP Parameters',
      'mousein1-wheel': 'MouseIn1 CHOP Parameters',
      'select2-params': 'Select2 CHOP Parameters',
      'filter4-params': 'Filter4 CHOP Parameters',
      'filter3-params': 'Filter3 CHOP Parameters',
      'filter2-params': 'Filter2 CHOP Parameters',
      'vert_rotation': 'Vertex Rotation GLSL',
      'vert_perspective': 'Vertex Perspective GLSL',
      'transform1': 'Transform1 TOP Parameters',
      'reorder1': 'Reorder1 TOP Parameters',
      'line_mindist': 'Line Min Distance Parameters'
    };
    
    // State for dialog management
    let currentHotspotDialog = null;
    let dialogTimeout = null;
    let isDialogHovered = false;
        
    // Tutorial Section Configuration
    const sectionConfig = {
      1: { 
        aspectRatio: "3615:1097", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/network_overview.png",
        hotspots: []
      },
      2: { 
        aspectRatio: "1852:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/chop_network.png",
        hotspots: []
      },
      3: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_uv_control.png",
        hotspots: [
          { top: "35%", left: "17%", type: "select1-detailed" }
        ]
      },
      4: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_velocity.png",
        hotspots: [
          { top: "4%", left: "29%", type: "math3-params" },
          { top: "4%", left: "52%", type: "filter1-params" }
        ]
      },
      5: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/centering_and_scaling.png",
        hotspots: [
          { top: "35%", left: "29%", type: "math1-params" },
          { top: "35%", left: "41%", type: "speed2-params" }
        ]
      },
      6: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/angular_velocity.png",
        hotspots: [
          { top: "30%", left: "65%", type: "math2-params" },
          { top: "28%", left: "76%", type: "speed3-params" }
        ]
      },
      7: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_wheel.png",
        hotspots: [
          { top: "67%", left: "3%", type: "mousein1-wheel" },
          { top: "67%", left: "15%", type: "select2-params" },
          { top: "67%", left: "29%", type: "filter4-params" },
          { top: "67%", left: "41%", type: "filter3-params" },
          { top: "67%", left: "53%", type: "filter2-params" }
        ]
      },
      8: { 
        aspectRatio: "1852:571", 
        offset: {x: 0.1, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/merging_and_null.png",
        hotspots: []
      },
      9: { 
        aspectRatio: "1456:478", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/euler_in.png",
        hotspots: []
      },
      10: { 
        aspectRatio: "1920:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/rotate_vertex_glsl.png",
        hotspots: [
          { top: "35%", left: "40%", type: "vert_rotation" }
        ]
      },
      11: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/prespective_glsl.png",
        hotspots: [
          { top: "40%", left: "50%", type: "vert_perspective" }
        ]
      },
      12: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/2d_points_to_2d_lines.png",
        hotspots: [
          { top: "45%", left: "35%", type: "transform1" },
          { top: "45%", left: "65%", type: "reorder1" }
        ]
      },
      13: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/sdf_uneven_capsule.png",
        hotspots: [
          { top: "50%", left: "50%", type: "line_mindist" }
        ]
      },
      14: { 
        aspectRatio: "1920:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/post_processing.png",
        hotspots: []
      }
    };

    // Section titles for header
    const sectionTitles = [
      "TESSERACT Tutorial",
      "TESSERACT Overview", 
      "The CHOP Network",
      "Input Data 1: Mouse UV Control",
      "Rangeling CHOPs 1: Mouse Velocity",
      "Rangeling CHOPs 2: Centering and Scaling", 
      "Rangeling CHOPs 3: Angular Velocity",
      "Rangeling CHOPs 4: Mouse Wheel",
      "Rangeling CHOPs 5: Merging and Null",
      "Input Data 2: Saved Data from TSV",
      "Rotation Vertex GLSL",
      "Perspective GLSL", 
      "2D Points to 2D Lines",
      "SDF Uneven Capsule",
      "Post Processing"
    ];

    // Tutorial State (made global for module access)
    let currentSection = 0;
    let tutorialOpen = false;
    let cleanupTimeout = null;
    let stickyHotspots = new Set();

    // Make state globally accessible
    window.currentSection = currentSection;
    window.tutorialOpen = tutorialOpen;

    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Data loading state
    let dataLoaded = {
      tsv: false,
      rotationGLSL: false,
      perspectiveGLSL: false,
      lineDistanceGLSL: false
    };

    // Initialize instances
    let tesseractShader = null;
    let enhancedControlPanel = null;
    let mobileSwipeGestures = null;
    let mobileMotionControl = null;

    // ==========================================
    // CORE TUTORIAL FUNCTIONS
    // ==========================================

    // Load tutorial content from external file
    function loadTutorialContent() {
      console.log('üìÑ Loading tutorial content...');
      
      return fetch('tutorials/tesseract/contentTesseract.html')
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to load tutorial content: ${response.status}`);
          }
          return response.text();
        })
        .then(html => {
          document.getElementById('tutorialContainer').outerHTML = html;
          console.log('‚úÖ Tutorial content loaded successfully');
        })
        .catch(error => {
          console.error('‚ùå Error loading tutorial content:', error);
          // Fallback content
          document.getElementById('tutorialContainer').innerHTML = `
            <div class="tutorial-container" id="tutorialContainer">
              <div class="tutorial-header">
                <div class="tutorial-title" id="currentSectionTitle">Tutorial Loading Error</div>
                <div class="tutorial-nav">
                  <button class="nav-btn close-btn" onclick="closeTutorial()">√ó</button>
                </div>
              </div>
              <div class="tutorial-content">
                <div style="padding: 2rem; text-align: center;">
                  <p>Failed to load tutorial content. Please refresh the page and try again.</p>
                  <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #00ffff; color: #000; border: none; border-radius: 5px; cursor: pointer;">
                    Reload Page
                  </button>
                </div>
              </div>
            </div>
          `;
        });
    }

    // Load dynamic content
    function loadDynamicContent() {
      // TSV loader
      fetch('./tutorials/tesseract/assets/code/euler_cycle.tsv')
        .then(res => {
          if (!res.ok) throw new Error('Failed to load TSV');
          return res.text();
        })
        .then(tsv => {
          const rows = tsv.trim().split('\n');
          const headers = rows[0].split('\t');
          const dataRows = rows.slice(1);
          
          const thead = document.querySelector('#tsvTable thead tr');
          if (thead) {
            thead.innerHTML = '';
            headers.forEach(header => {
              const th = document.createElement('th');
              th.textContent = header.trim();
              thead.appendChild(th);
            });
            
            const tbody = document.querySelector('#tsvTable tbody');
            if (tbody) {
              tbody.innerHTML = '';
              dataRows.forEach(row => {
                const cells = row.split('\t');
                const tr = document.createElement('tr');
                cells.forEach(cell => {
                  const td = document.createElement('td');
                  td.textContent = cell.trim();
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
            }
          }
          dataLoaded.tsv = true;
        })
        .catch(err => {
          console.error('Failed to load TSV:', err);
        });

      // Code snippet loaders
      const codeSnippets = [
        {
          id: 'rotationGLSLContent',
          url: 'tutorials/tesseract/assets/code/vert_rotation_pixel.frag',
          key: 'rotationGLSL'
        },
        {
          id: 'perspectiveGLSLContent', 
          url: 'tutorials/tesseract/assets/code/vert_perspective_pixel.frag',
          key: 'perspectiveGLSL'
        },
        {
          id: 'lineDistanceGLSLContent',
          url: 'tutorials/tesseract/assets/code/line_mindist_pixel.frag',
          key: 'lineDistanceGLSL'
        }
      ];

      codeSnippets.forEach(snippet => {
        fetch(snippet.url)
          .then(res => {
            if (!res.ok) throw new Error(`Failed to load ${snippet.key}`);
            return res.text();
          })
          .then(code => {
            const el = document.getElementById(snippet.id)?.querySelector('.code-content');
            if (el) {
              el.textContent = code;
              el.classList.remove('loading');
              dataLoaded[snippet.key] = true;
            }
          })
          .catch(err => {
            console.error(`Failed to load ${snippet.key}:`, err);
          });
      });
    }

    // Navigation functions
    function openTutorial() {
      console.log('üöÄ openTutorial called - starting tutorial!');
      
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      if (mobileBtn) {
        mobileBtn.style.opacity = '0';
        mobileBtn.style.visibility = 'hidden';
        mobileBtn.style.pointerEvents = 'none';
      }
      
      transitionToSection(1);
      initProgressBar();
    }

    function closeTutorial() {
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      if (mobileBtn && isMobile) {
        mobileBtn.style.opacity = '1';
        mobileBtn.style.visibility = 'visible';
        mobileBtn.style.pointerEvents = 'auto';
      }
      
      transitionToSection(0);
    }

    function goToNextSection() {
      if (currentSection < 14) {
        transitionToSection(currentSection + 1);
      }
    }

    function goToPrevSection() {
      if (currentSection > 1) {
        transitionToSection(currentSection - 1);
      }
    }

    function transitionToSection(newSection) {
      if (newSection === currentSection) return;
      
      currentSection = newSection;
      window.currentSection = currentSection; // Keep global state in sync
      
      updateSectionTitle();
      updateTutorial();
      
      if (currentSection > 0 && currentSection <= 14) {
        transitionStaticImage(currentSection);
      }
    }

    function updateTutorial() {
      const scroller = document.getElementById('tutorialScroller');
      const tutorialContainer = document.getElementById('tutorialContainer');
      const progressBar = document.getElementById('progressBar');
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      
      if (currentSection === 0) {
        if (tutorialContainer) {
          tutorialContainer.classList.remove('active');
        }
        if (progressBar) {
          progressBar.style.display = 'none';
        }
        
        if (mobileBtn && isMobile) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.pointerEvents = 'auto';
        }
        
        if (mobileMotionControl && isMobile) {
          mobileMotionControl.enable();
        }
        
        tutorialOpen = false;
        window.tutorialOpen = false;
      } else {
        if (tutorialContainer) {
          tutorialContainer.classList.add('active');
        }
        if (progressBar) {
          progressBar.style.display = 'flex';
        }
        
        if (mobileBtn) {
          mobileBtn.style.opacity = '0';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.pointerEvents = 'none';
        }
        
        if (mobileMotionControl && isMobile) {
          mobileMotionControl.disable();
        }
        
        tutorialOpen = true;
        window.tutorialOpen = true;
        
        if (scroller) {
          const offset = (currentSection - 1) * -100;
          scroller.style.transform = `translateX(${offset}vw)`;
        }
      }
      
      updateProgressBar();
    }

    function updateSectionTitle() {
      const titleElement = document.getElementById('currentSectionTitle');
      if (titleElement && currentSection >= 0 && currentSection < sectionTitles.length) {
        titleElement.textContent = sectionTitles[currentSection];
      }
    }

    function initProgressBar() {
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.innerHTML = '';
        
        for (let i = 1; i <= 14; i++) {
          const dot = document.createElement('div');
          dot.className = 'progress-dot';
          if (i === currentSection) dot.classList.add('active');
          dot.onclick = () => transitionToSection(i);
          progressBar.appendChild(dot);
        }
      }
    }

    function updateProgressBar() {
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', (index + 1) === currentSection);
      });
    }

    function setupMobileButton() {
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      const startBtn = document.getElementById('mobileStartBtn');
      
      if (isMobile) {
        if (mobileBtn && startBtn) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.pointerEvents = 'auto';
          
          startBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            openTutorial();
          });
        }
      } else {
        if (mobileBtn) {
          mobileBtn.style.display = 'none';
        }
      }
    }

    // Image transition and hotspot functions (simplified versions)
    let currentTransition = null;
    let transitionCounter = 0;

    function transitionStaticImage(newSection) {
      const config = sectionConfig[newSection];
      if (!config) return;
    
      const imageContainer = document.getElementById('staticImageContainer');
      if (!imageContainer) return;
    
      if (currentTransition) {
        currentTransition.cancelled = true;
      }
      
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }

      const transitionId = ++transitionCounter;
      currentTransition = { id: transitionId, cancelled: false };
      
      const existingImages = imageContainer.querySelectorAll('.tutorial-image');
      const currentImage = existingImages.length > 0 ? existingImages[existingImages.length - 1] : null;
      
      const newImage = document.createElement('img');
      newImage.className = 'tutorial-image';
      newImage.style.aspectRatio = config.aspectRatio.replace(':', '/');
      newImage.src = config.image;
      newImage.dataset.transitionId = transitionId;

      if (config.offset.x === 0 && config.offset.y === 0) {
        newImage.style.transform = 'translate(0, 0)';
        newImage.style.opacity = '0';
        newImage.style.zIndex = '10';
      } else {
        const startX = config.offset.x * 100;
        const startY = config.offset.y * 100;
        newImage.style.transform = `translate(${startX}%, ${startY}%)`;
        newImage.style.opacity = '0';
        newImage.style.zIndex = '10';
      }

      if (currentImage) {
        currentImage.style.zIndex = '5';
      }

      imageContainer.appendChild(newImage);
      
      function executeTransition() {
        if (currentTransition.cancelled || currentTransition.id !== transitionId) {
          newImage.remove();
          return;
        }
        
        updateHotspots(config.hotspots);

        setTimeout(() => {
          if (currentTransition.cancelled || currentTransition.id !== transitionId) {
            newImage.remove();
            return;
          }

          newImage.style.opacity = '1';
          newImage.style.transform = 'translate(0, 0)';

          if (currentImage && currentImage.parentNode === imageContainer) {
            if (config.offset.x === 0 && config.offset.y === 0) {
              currentImage.style.opacity = '0';
            } else {
              const exitX = -config.offset.x * 100;
              const exitY = -config.offset.y * 100;
              currentImage.style.transform = `translate(${exitX}%, ${exitY}%)`;
              currentImage.style.opacity = '0';
            }
          }

          cleanupTimeout = setTimeout(() => {
            if (currentTransition.id === transitionId) {
              const allImages = imageContainer.querySelectorAll('.tutorial-image');
              allImages.forEach(img => {
                if (img !== newImage && img.parentNode === imageContainer) {
                  imageContainer.removeChild(img);
                }
              });
              
              if (currentTransition.id === transitionId) {
                currentTransition = null;
              }
            }
            cleanupTimeout = null;
          }, 850);
        }, 10);
      }
      
      if (newImage.complete) {
        executeTransition();
      } else {
        newImage.onload = executeTransition;
        newImage.onerror = () => {
          console.error('Failed to load image:', config.image);
          if (currentTransition.id === transitionId) {
            newImage.remove();
            currentTransition = null;
          }
        };
      }
    }

    function updateHotspots(hotspots) {
      const hotspotContainer = document.getElementById('hotspotContainer');
      if (!hotspotContainer) return;
    
      stickyHotspots.clear();
      hotspotContainer.innerHTML = '';
    
      if (isMobile) return; // No hotspots on mobile
      
      // Create hotspots for desktop
      hotspots.forEach((hotspotConfig, index) => {
        const hotspot = document.createElement('div');
        hotspot.className = 'hotspot';
        hotspot.style.top = hotspotConfig.top;
        hotspot.style.left = hotspotConfig.left;
        hotspot.dataset.type = hotspotConfig.type;
        hotspot.dataset.index = index;
        
        // Add click handler for sticky behavior
        hotspot.addEventListener('click', (e) => {
          e.stopPropagation();
          const rect = hotspot.getBoundingClientRect();
          toggleStickyDialog(hotspotConfig.type, hotspot, rect.right + 10, rect.top);
        });
        
        // Add hover handlers with improved logic
        hotspot.addEventListener('mouseenter', (e) => {
          if (!stickyHotspots.has(hotspot)) {
            const rect = hotspot.getBoundingClientRect();
            showParameterDialog(hotspotConfig.type, rect.right + 10, rect.top, hotspot);
          }
        });
        
        hotspot.addEventListener('mouseleave', (e) => {
          if (!stickyHotspots.has(hotspot)) {
            // Add a small delay to prevent flashing
            scheduleHideDialog(hotspot);
          }
        });
        
        hotspotContainer.appendChild(hotspot);
      });
    }
    
    function showParameterDialog(type, x, y, sourceHotspot = null) {
      // Clear any pending hide
      if (dialogTimeout) {
        clearTimeout(dialogTimeout);
        dialogTimeout = null;
      }
    
      const dialog = document.getElementById('parameterDialog');
      if (!dialog) return;
      
      // Check if we have a mapping for this parameter type
      const imageName = parameterImageMap[type];
      if (!imageName) {
        console.warn(`No image mapping found for parameter type: ${type}`);
        return;
      }
      
      // Construct correct image path (note lowercase 'parameters')
      const imagePath = `Tesseract%20Tutorial%20Pictures/parameters/${imageName}`;
      const title = parameterTitleMap[type] || type;
      
      // Update dialog content
      const titleEl = dialog.querySelector('#parameterTitle');
      let imageEl = dialog.querySelector('img');
      
      // Create image element if it doesn't exist
      if (!imageEl) {
        imageEl = document.createElement('img');
        const contentEl = dialog.querySelector('#parameterContent');
        if (contentEl) {
          contentEl.appendChild(imageEl);
        }
      }
      
      if (titleEl) titleEl.textContent = title;
      if (imageEl) {
        imageEl.src = imagePath;
        imageEl.style.display = 'block';
        imageEl.style.width = '100%';
        imageEl.style.maxWidth = '525px';
        imageEl.style.borderRadius = '5px';
        imageEl.style.marginTop = '0.5rem';
        
        // Add error handling for missing images
        imageEl.onerror = () => {
          console.error(`Failed to load parameter image: ${imagePath}`);
          imageEl.style.display = 'none';
          const contentEl = dialog.querySelector('#parameterContent');
          if (contentEl) {
            contentEl.innerHTML = `<p style="color: #ff6b6b; font-style: italic;">Image not available: ${imageName}</p>`;
          }
        };
      }
      
      // Smart positioning to avoid overlap with hotspot
      const dialogWidth = 320;
      const dialogHeight = 250;
      
      // Position to the right of the hotspot, but adjust if it would go off-screen
      let finalX = Math.min(x, window.innerWidth - dialogWidth - 20);
      let finalY = Math.min(y, window.innerHeight - dialogHeight - 20);
      
      // If positioning to the right would overlap with source hotspot, try other positions
      if (sourceHotspot) {
        const hotspotRect = sourceHotspot.getBoundingClientRect();
        
        // If right position overlaps, try left
        if (finalX < hotspotRect.right + 50) {
          finalX = Math.max(20, hotspotRect.left - dialogWidth - 10);
        }
        
        // If still overlapping or off-screen, position below
        if (finalX < 20 || finalX + dialogWidth > window.innerWidth - 20) {
          finalX = Math.min(hotspotRect.left, window.innerWidth - dialogWidth - 20);
          finalY = Math.min(hotspotRect.bottom + 10, window.innerHeight - dialogHeight - 20);
        }
      }
      
      // Position dialog
      dialog.style.left = finalX + 'px';
      dialog.style.top = finalY + 'px';
      
      // Add dialog hover handlers to prevent premature hiding
      if (!dialog.hasAttribute('data-hover-setup')) {
        dialog.addEventListener('mouseenter', () => {
          isDialogHovered = true;
          if (dialogTimeout) {
            clearTimeout(dialogTimeout);
            dialogTimeout = null;
          }
        });
        
        dialog.addEventListener('mouseleave', () => {
          isDialogHovered = false;
          if (currentHotspotDialog && !stickyHotspots.has(currentHotspotDialog)) {
            scheduleHideDialog();
          }
        });
        
        dialog.setAttribute('data-hover-setup', 'true');
      }
      
      // Show dialog
      dialog.classList.add('active');
      currentHotspotDialog = sourceHotspot;
    }
    
    function scheduleHideDialog(sourceHotspot = null) {
      // Clear any existing timeout
      if (dialogTimeout) {
        clearTimeout(dialogTimeout);
      }
      
      // Only hide if not hovered and not sticky
      dialogTimeout = setTimeout(() => {
        if (!isDialogHovered && (!sourceHotspot || !stickyHotspots.has(sourceHotspot))) {
          hideParameterDialog();
        }
        dialogTimeout = null;
      }, 200); // Small delay to prevent flashing
    }
    
    function toggleStickyDialog(type, hotspot, x, y) {
      if (stickyHotspots.has(hotspot)) {
        // Remove sticky state
        stickyHotspots.delete(hotspot);
        hotspot.classList.remove('sticky');
        hideParameterDialog();
      } else {
        // Add sticky state
        stickyHotspots.add(hotspot);
        hotspot.classList.add('sticky');
        showParameterDialog(type, x, y, hotspot);
      }
    }
    
    function hideParameterDialog() {
      const dialog = document.getElementById('parameterDialog');
      if (dialog) {
        dialog.classList.remove('active');
      }
      currentHotspotDialog = null;
      
      // Clear any pending timeouts
      if (dialogTimeout) {
        clearTimeout(dialogTimeout);
        dialogTimeout = null;
      }
    }
    
    // Enhanced click outside handler
    document.addEventListener('click', (e) => {
      const dialog = document.getElementById('parameterDialog');
      const hotspotContainer = document.getElementById('hotspotContainer');
      
      // Check if click is outside hotspots and dialog
      if (dialog && dialog.classList.contains('active') && 
          !dialog.contains(e.target) && 
          (!hotspotContainer || !hotspotContainer.contains(e.target))) {
        
        // Clear all sticky hotspots
        stickyHotspots.clear();
        document.querySelectorAll('.hotspot.sticky').forEach(h => {
          h.classList.remove('sticky');
        });
        
        hideParameterDialog();
      }
    });
    
    // Make sure these functions are globally accessible
    window.showParameterDialog = showParameterDialog;
    window.hideParameterDialog = hideParameterDialog;
    window.updateHotspots = updateHotspots;
        
    function onWheel(event) {
      const anyModalOpen = document.querySelector('.widget-fullscreen.active');
      
      if (anyModalOpen) {
        return;
      }
    
      if (tutorialOpen) {
        event.preventDefault();
        const delta = event.deltaY;
        
        if (delta > 0) {
          goToNextSection();
        } else {
          goToPrevSection();
        }
        return;
      }
    }

    // Make key functions globally accessible
    window.openTutorial = openTutorial;
    window.closeTutorial = closeTutorial;
    window.goToNextSection = goToNextSection;
    window.goToPrevSection = goToPrevSection;
    window.transitionToSection = transitionToSection;

    // ==========================================
    // INITIALIZATION
    // ==========================================

    async function init() {
      try {
        console.log('üöÄ Starting tutorial initialization...');
        
        // Load tutorial content first
        await loadTutorialContent();
        console.log('‚úÖ Tutorial content loaded');
        
        // Initialize Tesseract shader
        tesseractShader = new TesseractShader('hypercube-canvas', {
          onTutorialOpen: openTutorial,
          getTutorialState: () => tutorialOpen
        });
        
        await tesseractShader.init();
        console.log('‚úÖ TesseractShader initialized');
        
        // Initialize Enhanced Control Panel
        enhancedControlPanel = new EnhancedControlPanel(tesseractShader);
        window.enhancedControlPanel = enhancedControlPanel;
        console.log('‚úÖ Enhanced Control Panel initialized');
        
        loadDynamicContent();
        initProgressBar();
        updateSectionTitle();
        setupMobileButton();
        
        // Initialize mobile features
        if (isMobile) {
          try {
            mobileSwipeGestures = new MobileSwipeGestures();
            console.log('‚úÖ Mobile swipe gestures initialized');
          } catch (error) {
            console.warn('‚ö†Ô∏è Mobile swipe gestures failed to initialize:', error);
          }
          
          try {
            mobileMotionControl = new MobileMotionControl(tesseractShader);
            window.mobileMotionControl = mobileMotionControl;
            console.log('‚úÖ Mobile motion control initialized');
          } catch (error) {
            console.warn('‚ö†Ô∏è Mobile motion control failed to initialize:', error);
          }
        }
        
        // Setup wheel event for tutorial navigation
        document.addEventListener('wheel', onWheel, { passive: false });
        
        console.log('üéâ Tutorial initialization complete!');
      } catch (error) {
        console.error('‚ùå Failed to initialize tutorial application:', error);
        
        // Basic fallback UI
        const heroSection = document.getElementById('heroSection');
        if (heroSection) {
          heroSection.innerHTML += `
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                        background: rgba(255, 0, 0, 0.8); color: white; padding: 2rem; border-radius: 10px;
                        text-align: center; z-index: 9999;">
              <h2>Loading Error</h2>
              <p>Failed to initialize tutorial: ${error.message}</p>
              <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; 
                      background: white; color: black; border: none; border-radius: 5px; cursor: pointer;">
                Reload Page
              </button>
            </div>
          `;
        }
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    // Close modals with escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        // Close any open modals
        document.querySelectorAll('.widget-fullscreen.active').forEach(modal => {
          modal.classList.remove('active');
        });
        
        // Hide parameter dialog
        const dialog = document.getElementById('parameterDialog');
        if (dialog) {
          dialog.classList.remove('active');
        }
      }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (mobileSwipeGestures) {
        mobileSwipeGestures.destroy();
      }
      if (mobileMotionControl) {
        mobileMotionControl.destroy();
      }
      if (tesseractShader) {
        tesseractShader.destroy();
      }
    });
  </script>
</body>
</html>
